/* -----------------------ex3a---------------------------------------------

 */
//-------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <time.h>
//-------------------------------------------------------------------------
#define ARR_LEN 50000
#define RAND_RANGE 200000
//-------------------------------------------------------------------------
void terminate(void);
void rs_son(int arr[],int pipe_descs[]);
void bs_son(int arr[],int pipe_descs[]);
void quick_sort (int arr[],int low,int high);
int binary_search(int arr[], int low, int high, int wanted_value);
void swap(int* a, int* b);
int partition (int arr[], int low, int high);
//-------------------------------------------------------------------------
int main () {
    srand(17);
    char number[sizeof(int)];
    int random_arr [ARR_LEN];
    int i,num;
    int bs_sum=0,rs_sum=0,rs_min=100,bs_min=100,rs_max=0,bs_max=0;
    double rs_avg,bs_avg;
    //get random numbers into the array:
    for(i=0;i<ARR_LEN ; i++){
        num=rand()%RAND_RANGE;
        random_arr[i]=num;
    }
    quick_sort(random_arr,0,ARR_LEN-1); //sort the array

    int pipe_descs1[2]; //create a pipe for rs_son
    if(pipe(pipe_descs1)==-1)
        terminate();
    int pipe_descs2[2]; //create a pipe for bs_son
        if(pipe(pipe_descs2)==-1)
            terminate();
    pid_t status;
    //dad fork two sons:
    for(i=0;i<2;i++){
        status=fork();
        switch(status){
            case -1: {
                terminate();
                break;
            }
            case 0: {

                //into the first free
                if(i==0)
                    rs_son(random_arr, pipe_descs1);
                else
                    bs_son(random_arr, pipe_descs2);
                break;
            }
            default: break;
        }
    }
    close(pipe_descs1[0]); //father write,close read
    dup2(pipe_descs1[1],STDOUT_FILENO); //close stdout & copy pipe_descs1[1]
    close(pipe_descs2[0]); //father write,close read
    dup2(pipe_descs2[1],STDOUT_FILENO); //close stdout & copy pipe_descs2[1]
    //into the first free
    ssize_t ret; //return value of write command

    for(i=0 ; i< 1000 ; i++){
        num=rand()%RAND_RANGE;
        ret=write(pipe_descs1[1],&num,sizeof(int)); //parent write to the pipes
        ret=write(pipe_descs2[1],&num,sizeof(int));
        if(ret<0)
            terminate();
        //read+atoi+calculate

        read(pipe_descs1[0],number,sizeof(int));
        num=atoi(number);
        rs_sum+=num;
        if(num>rs_max)
        	rs_max=num;

        read(pipe_descs2[0],number,sizeof(int));
                num=atoi(number);
                bs_sum+=num;
                if(num>bs_max)
                	bs_max=num;
    }

    //clculate avg+ print details
    return EXIT_SUCCESS;
}

//=========================================================================
//this function terminate the program if there is an error in fork
void terminate(){
    perror ("error in fork()/pipe");
    exit(EXIT_FAILURE);
}
//-------------------------------------------------------------------------
void rs_son(int arr[],int pipe_descs1[]){
	close(pipe_descs1[1]); //son read,close write
	dup2(pipe_descs1[0],STDIN_FILENO); //close stdin & copy pipe_decs1[0]
	int i, num;
    ssize_t nbytes;
    char number[sizeof(int)];
    nbytes=read(pipe_descs1[0],number,sizeof(int));
    num=atoi(number);
    while(num!=-1){
        time_t time_before=time(NULL);
        for (i=0 ; i<ARR_LEN ; i++){
            if(arr[i]==num)
                break;
        }
        time_t time_after=time(NULL);
        time_t real_time=time_after-time_before; //calculate the time search
        printf("%d",(int)real_time);
        nbytes=read(pipe_descs1[0],number,sizeof(int));
        num=atoi(number);
    }

    exit (EXIT_SUCCESS);
}
//-------------------------------------------------------------------------
void bs_son(int arr[],int pipe_descs2[]){
	close(pipe_descs2[1]); //son read,close write
		dup2(pipe_descs2[0],STDIN_FILENO); //close stdin & copy pipe_decs2[0]
	int num, is_exist;
    ssize_t nbytes;
    char number[sizeof(int)];
    nbytes = read(pipe_descs2[0],number,sizeof(int));
    num=atoi(number);
    while(num!=-1){
        time_t time_before=time(NULL);
        is_exist=binary_search(arr,0,ARR_LEN-1,num);
        time_t time_after=time(NULL);
        time_t real_time=time_after-time_before; //calculate the time search
        printf("%d",(int)real_time);
        nbytes = read(pipe_descs2[0],number,sizeof(int));
        num=atoi(number);
    }

    exit (EXIT_SUCCESS);
}
//-------------------------------------------------------------------------
// A utility function to swap two elements
void swap(int* a, int* b)
{
    int t = *a;
    *a = *b;
    *b = t;
}
//-------------------------------------------------------------------------
/* This function takes last element as pivot, places
 the pivot element at its correct position in sorted
 array, and places all smaller (smaller than pivot)
 to left of pivot and all greater elements to right
 of pivot */
int partition (int arr[], int low, int high)
{
    int pivot = arr[high];    // pivot
    int i = (low - 1);  // Index of smaller element

    for (int j = low; j <= high- 1; j++)
    {
        // If current element is smaller than the pivot
        if (arr[j] < pivot)
        {
            i++;    // increment index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}
//-------------------------------------------------------------------------
/* The main function that implements QuickSort
 arr[] --> Array to be sorted,
 low  --> Starting index,
 high  --> Ending index */
void quick_sort(int arr[], int low, int high)
{
    if (low < high)
    {
        /* pi is partitioning index, arr[p] is now
         at right place */
        int pi = partition(arr, low, high);

        // Separately sort elements before
        // partition and after partition
        quick_sort(arr, low, pi - 1);
        quick_sort(arr, pi + 1, high);
    }
}
//-------------------------------------------------------------------------
int binary_search(int arr[], int low, int high, int wanted_value)
{
    if (high >= low) {
        int mid = low + (high - low) / 2;

        // If the element is present at the middle
        // itself
        if (arr[mid] == wanted_value)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > wanted_value)
            return binary_search(arr, low, mid - 1, wanted_value);

        // Else the element can only be present
        // in right subarray
        return binary_search(arr, mid + 1, high, wanted_value);
    }

    // We reach here when element is not
    // present in array
    return -1;
}
